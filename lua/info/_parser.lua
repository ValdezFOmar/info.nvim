-- Captures generated by the `manual_pattern`

---@class info.parser.Position
---@field start integer
---@field end_ integer

---@class info.parser.TextPosition : info.parser.Position
---@field text string

---@class info.parser.Header.Pair : info.parser.Position
---@field value info.parser.TextPosition

---@class info.parser.Reference : info.parser.Position
---@field type info.Element
---@field label info.parser.TextPosition
---@field target? info.parser.TextPosition

---@class info.parser.Header
---@field file info.parser.Header.Pair
---@field node info.parser.Header.Pair
---@field next? info.parser.Header.Pair
---@field prev? info.parser.Header.Pair
---@field up? info.parser.Header.Pair

---@class info.parser.Captures
---@field header info.parser.Header
---@field references info.parser.Reference[]

-- Final elements stored in `vim.b._info_manual` after processing the captures

---@class info.CharPosition
---@field line integer
---@field col integer

---@class info.EditorPosition
---@field start info.CharPosition
---@field end_ info.CharPosition

---@class info.Document.Relation : info.EditorPosition
---@field target { file: string, node: string }

---@class info.Document.XRef : info.EditorPosition
---@field label string
---@field target { file: string, node: string }

---@class info.Document.Header
---@field next? info.Document.Relation
---@field prev? info.Document.Relation
---@field up? info.Document.Relation

---@class info.Document
---@field file string
---@field node string
---@field relations info.Document.Header
---@field xreferences info.Document.XRef[]
---@field menu_entries info.Document.XRef[]

---@enum info.Element
local ElementType = {
    MenuEntry = 1,
    XReference = 2,
}

local M = {}

local lpeg = vim.lpeg
local S = lpeg.S
local P = lpeg.P
local B = lpeg.B
local Cp = lpeg.Cp
local Ct = lpeg.Ct
local Cg = lpeg.Cg

local START = Cg(Cp(), 'start')
local END = Cg(Cp(), 'end_')

---@param pattern vim.lpeg.Pattern
---@param name string?
---@return vim.lpeg.Pattern
local function Cpos(pattern, name)
    return START * Cg(pattern, name or 'text') * END
end

---@param name string
---@param pattern vim.lpeg.Pattern
---@return vim.lpeg.Pattern
local function Cgt(name, pattern)
    return Cg(Ct(pattern), name)
end

---@param pattern any
local function opt(pattern)
    return P(pattern) ^ -1
end

---@param element info.Element
---@return vim.lpeg.Pattern
local function Ctype(element)
    return Cg(lpeg.Cc(element), 'type')
end

--- Info manual PEG parser
local manual_pattern = (function()
    local SP = S ' \t' ^ 1 --- spaces
    local MSP = S ' \t\n' ^ 1 --- multi line spaces
    local SWALLOW_LINE = (P(1) - '\n') ^ 0 * '\n'

    ---@param key string
    ---@return vim.lpeg.Pattern
    local function header_key(key)
        local text = (P(1) - S ',\n\t') ^ 1
        return START * Cgt('value', key * SP * Cpos(text)) * END
    end

    local COMMA = ',' * SP
    local file_name = header_key 'File:'
    local this_node = header_key 'Node:'
    local next_node = header_key 'Next:'
    local prev_node = header_key 'Prev:'
    local up_node = header_key 'Up:'
    local node_header = Cgt('file', file_name)
        * COMMA
        * Cgt('node', this_node)
        * opt(COMMA * Cgt('next', next_node))
        * opt(COMMA * Cgt('prev', prev_node))
        * opt(COMMA * Cgt('up', up_node))
        * SWALLOW_LINE -- Extra text (see `info --file dir`)

    local reference_text = (P(1) - ':') ^ 1
    local reference_node = (P(1) - S '.,\t\n') ^ 1
    local reference = Cgt('label', Cpos(reference_text))
        * ':'
        * (':' + SP * Cgt('target', Cpos(reference_node)))

    local menu_entry = Ctype(ElementType.MenuEntry)
        * B '\n' -- menu entries only appear at the start of lines
        * START
        * '* '
        * reference
        * END
        * SWALLOW_LINE -- entry description / comment

    local inline_reference = Ctype(ElementType.XReference)
        * START
        * '*'
        * S 'Nn'
        * 'ote'
        * MSP -- reference can continue the next line
        * reference
        * END

    local line = Ct(menu_entry) + Ct(inline_reference) + 1

    return Ct(Cgt('header', node_header) * Cgt('references', line ^ 0) * -1)
end)()

-- local lines_pattern = Ct(Ct(START * (P(1) - '\n') ^ 0 * END * '\n') ^ 0)

---@param ref string
---@return string? file
---@return string? node
function M.parse_reference(ref)
    ---@type string?, integer?
    local file, len = ref:match '^%(([^)]+)%)()'
    local node = nil ---@type string?
    if not len then
        node = ref
    elseif len - 1 ~= #ref then
        node = ref:sub(len)
    end
    return file, node
end

---@param rel info.parser.Header.Pair
---@param file string
---@return info.Document.Relation
local function build_relation(rel, file)
    local xfile, node = M.parse_reference(rel.value.text)
    return {
        start = { line = 1, col = rel.start },
        end_ = { line = 1, col = rel.end_ },
        target = {
            file = xfile or file,
            node = node or 'Top',
        }
    }
end

---Parse and info document node.
---@param text string
---@return info.Document?
function M.parse(text)
    ---@type info.parser.Captures?
    local caps = manual_pattern:match(text)
    if not caps then
        return
    end

    local file = caps.header.file.value.text
    local node = caps.header.node.value.text
    local next = caps.header.next
    local prev = caps.header.prev
    local up = caps.header.up

    local xreferences = {} ---@type info.Document.XRef[]
    local menu_entries = {} ---@type info.Document.XRef[]

    -- TODO: Normalize references
    for _, reference in ipairs(caps.references) do
        if reference.type == ElementType.MenuEntry then
            table.insert(menu_entries, reference)
        elseif reference.type == ElementType.XReference then
            table.insert(xreferences, reference)
        end
    end

    ---@type info.Document
    return {
        file = file,
        node = node,
        relations = {
            next = next and build_relation(next, file),
            prev = prev and build_relation(prev, file),
            up = up and build_relation(up, file),
        },
        xreferences = xreferences,
        menu_entries = menu_entries,
    }
end

return M
